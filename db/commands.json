{
    "beg":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 30, commands.BucketType.user)\n",
        "    async def beg(self, ctx):\n",
        "        coins = random.randint(1, 5000)\n",
        "        userdat[str(ctx.message.author.id)][0] += coins\n",
        "        self.save()\n",
        "        await ctx.reply(f\"You earned {coins} coins\")\n\n"
    ],
    "ping":[
        "    @commands.command()\n",
        "    async def ping(self, ctx):\n",
        "        await ctx.send(f'Pong! My ping is {round(self.client.latency * 1000)}ms')\n\n"
    ],
    "say":[
        "    @commands.command()\n",
        "    async def say(self, ctx, *, msg):\n",
        "        await ctx.send(msg)\n\n"
    ],
    "work":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 1800, commands.BucketType.user)\n",
        "    async def work(self, ctx):\n",
        "        coins = random.randint(5000, 50000)\n",
        "        userdat[str(ctx.message.author.id)][0] += coins\n",
        "        self.save()\n",
        "        await ctx.reply(f\"You earned {coins} coins\")\n\n"
    ],
    "invest":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def invest(self, ctx, action:str):\n",
        "        if str(action) == \"claim\":\n",
        "            if str(ctx.message.author.id) not in money or userdat[str(ctx.message.author.id)][2] == 0: return await ctx.reply(\"You didnt invest any coins. Type `.invest <amount>` to invest some coins\")\n",
        "            i = datetime.datetime.now() - cd[str(ctx.message.author.id)]\n",
        "            if i is None or i.seconds > invest_time: cd[str(ctx.message.author.id)] = datetime.datetime.now()\n",
        "            else: return await ctx.reply(\"You cant claim your money yet\")\n",
        "            rnd = ''.join(map(str, random.choices([0, 0.5, 0.75, 1.25, 1.5, 1.75, 2, 2.5, 5], weights=[0.5, 3, 5, 75, 45, 5, 3, 1, 0.5], k=1)))\n",
        "            userdat[str(ctx.message.author.id)][3] = 0\n",
        "            a = round(userdat[str(ctx.message.author.id)][2] * float(rnd))\n",
        "            userdat[str(ctx.message.author.id)][0] += a\n",
        "            userdat[str(ctx.message.author.id)][2] = 0\n",
        "            return await ctx.reply(f\"You claimed {a} coins with {rnd} profit.\")\n",
        "        elif str(action) == \"all\" or str(action) == \"max\":\n",
        "            if userdat[str(ctx.message.author.id)][0] < 10000: return await ctx.reply(\"You can't invest less than 10000 coins\")\n",
        "            else:\n",
        "                def check(msg):\n",
        "                    return msg.author == ctx.message.author and msg.channel == ctx.message.channel and (msg.content)\n",
        "                await ctx.reply(f\"Are you sure you want to invest {userdat[str(ctx.message.author.id)][0]} coins? If you invest them you wont have them in your wallet for some time\\nYou can claim after the coins after some time using `.invest claim`\\nType yes or no\")\n",
        "                msg = await self.client.wait_for(\"message\", check=check)\n",
        "                if msg.content.lower() == \"no\": return await ctx.send(\"Ok guess you are not gonna invest today\")\n",
        "                elif msg.content.lower() == \"yes\":\n",
        "                    try:\n",
        "                        i = datetime.datetime.now() - cd[str(ctx.message.author.id)]\n",
        "                    except KeyError:\n",
        "                        i = None\n",
        "                        cd[str(ctx.message.author.id)] = datetime.datetime.now()\n",
        "                    if i is None or i.seconds > invest_time: cd[str(ctx.message.author.id)] = datetime.datetime.now()\n",
        "                    else: return await ctx.reply(\"You already have invested coins\")\n",
        "                    if userdat[str(ctx.message.author.id)][2] == 0: pass\n",
        "                    else: return await ctx.send(\"There are unclaimed coins. Type `.invest claim` to claim them\")\n",
        "                    userdat[str(ctx.message.author.id)][2] += userdat[str(ctx.message.author.id)][0]\n",
        "                    await ctx.send(f\"You invested {userdat[str(ctx.message.author.id)][2]} coins. Come back in {round(invest_time / 3600)} hours to claim your coins\")\n",
        "                    userdat[str(ctx.message.author.id)][0] = 0\n",
        "                    self.save()\n",
        "                    return\n",
        "                else: return await ctx.send(f\"You are supposed to type yes or no. Not {msg.content}\")\n",
        "        else:\n",
        "            try:\n",
        "                float(action)\n",
        "            except Exception as e:\n",
        "                if action.endswith(\"k\"):\n",
        "                    i = action.replace(\"k\", \"\")\n",
        "                    action = int(i) * 1000\n",
        "                elif action.endswith(\"m\"):\n",
        "                    i = action.replace(\"m\", \"\")\n",
        "                    action = int(i) * 1000000\n",
        "                elif action.endswith(\"b\"):\n",
        "                    i = action.replace(\"b\", \"\")\n",
        "                    action = int(i) * 1000000000\n",
        "                else: return await ctx.reply(e)\n",
        "            if int(float(action)) <= 0 or not float(action).is_integer():\n",
        "                return await ctx.reply(\"Don't try to break me dood\")\n",
        "            if int(float(action)) < 10000: return await ctx.reply(\"You can't invest less than 10000 coins\")\n",
        "            else:\n",
        "                if int(float(action)) > userdat[str(ctx.message.author.id)][0]: return await ctx.reply(\"You dont have that many coins in your wallet\")\n",
        "                else:\n",
        "                    m = round(sys.maxsize / 5)\n",
        "                    maxv = m - 1\n",
        "                    def check(msg):\n",
        "                        return msg.author == ctx.message.author and msg.channel == ctx.message.channel and (msg.content)\n",
        "\n",
        "                    await ctx.reply(f\"Are you sure you want to invest {int(float(action))} coins? If you invest them you wont have them in your wallet for some time\\nYou can claim after the coins after some time using `.invest claim`\\nType yes or no\")\n",
        "                    msg = await self.client.wait_for(\"message\", check=check)\n",
        "                    if msg.content == \"no\": return await ctx.send(\"Ok guess you are not gonna invest today\")\n",
        "                    elif msg.content == \"yes\":\n",
        "                        try:\n",
        "                            i = datetime.datetime.now() - cd[str(ctx.message.author.id)]\n",
        "                        except KeyError:\n",
        "                            i = None\n",
        "                            cd[str(ctx.message.author.id)] = datetime.datetime.now()\n",
        "                        if i is None or i.seconds > invest_time: cd[str(ctx.message.author.id)] = datetime.datetime.now()\n",
        "                        else: return await ctx.reply(\"You already have invested coins\")\n",
        "                        if userdat[str(ctx.message.author.id)][2] == 0: pass\n",
        "                        else: return await ctx.send(\"There are unclaimed coins. Type `.invest claim` to claim them\")\n",
        "                        userdat[str(ctx.message.author.id)][2] += int(action)\n",
        "                        userdat[str(ctx.message.author.id)][0] -= int(action)\n",
        "                        self.save()\n",
        "                        await ctx.send(f\"You invested {int(float(action))} coins. Come back in {round(invest_time / 3600)} hours to claim your coins\")\n",
        "                    else:\n",
        "                        await ctx.send(f\"You are supposed to type yes or no. Not {msg.content}\")\n\n"
    ],
    "shutdown":[
        "    @commands.command()\n",
        "    async def shutdown(self, ctx):\n",
        "        if ctx.message.author.id == owner_id:\n",
        "            raise SystemExit\n\n"
    ],
    "meme":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def meme(self, ctx):\n",
        "        async with ctx.typing():\n",
        "            re = ['memes', 'meme', 'dankmemes']\n",
        "            memes_submissions = reddit.subreddit(random.choice(re)).hot()\n",
        "            post_to_pick = random.randint(1, 100)\n",
        "            for i in range(0, post_to_pick):\n",
        "                submission = next(x for x in memes_submissions if not x.stickied)\n",
        "            embed = discord.Embed(title = submission.title, color=discord.Colour.random())\n",
        "            embed.set_image(url=submission.url)\n",
        "        await ctx.send(embed = embed)\n\n"
    ],
    "reddit":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def reddit(self, ctx, sub:str):\n",
        "        block = [\"nsfw\", \"nude\", \"porn\", \"cum\", \"cock\", \"dick\"]\n",
        "        if any(x in sub.lower() for x in block):\n",
        "            if sub == \"unixporn\": pass\n",
        "            else: return await ctx.reply(\"no nsfw\")\n",
        "        async with ctx.typing():\n",
        "            try:\n",
        "                memes_submissions = reddit.subreddit(sub).hot()\n",
        "                post_to_pick = random.randint(1, 100)\n",
        "                for i in range(0, post_to_pick): submission = next(x for x in memes_submissions if not x.stickied)\n",
        "                embed = discord.Embed(title = submission.title, color=discord.Colour.random())\n",
        "                embed.set_image(url=submission.url)\n",
        "                await ctx.send(embed = embed)\n",
        "            except prawcore.exceptions.Redirect:\n",
        "                await ctx.reply(f\"No subreddit named {sub} found\")\n\n"
    ],
    "add":[
        "    @commands.command()\n",
        "    async def add(self, ctx, user:discord.User, amount:int, place:str=None):\n",
        "        if ctx.message.author.id == userid:\n",
        "            if str(user.id) not in userdat:\n",
        "                self.addv(userdat, str(user.id), [0, 0, 0])\n",
        "                self.save()\n",
        "            if place == None or str(place) == \"wallet\":\n",
        "                userdat[str(user.id)][0] += int(amount)\n",
        "                await ctx.reply(f\"Added {amount} coins to {user.display_name}'s wallet\")\n",
        "                self.save()\n",
        "                return\n",
        "            elif place == \"bank\":\n",
        "                userdat[str(user.id)][1] += int(amount)\n",
        "                self.save()\n",
        "                await ctx.reply(f\"Added {amount} coins in {user.display_name}'s bank\")\n",
        "                return\n",
        "            else:\n",
        "                raise BadArgument\n\n"
    ],
    "poll":[
        "    @commands.command(pass_context=True)\n",
        "    async def poll(self, ctx, question, *options: str):\n",
        "        if len(options) <= 1:\n",
        "            await ctx.send('You need more than one option to make a poll')\n",
        "            returnnest_asyncio.apply()\n",
        "        if len(options) > 10:\n",
        "            await ctx.send('You cant make a poll for more than 10 options')\n",
        "            return\n",
        "        if len(options) == 2 and options[0] == 'yes' and options[1] == 'no':\n",
        "            reactions = ['✅', '❌']\n",
        "        else:\n",
        "            reactions = ['1⃣', '2⃣', '3⃣', '4⃣', '5⃣', '6⃣', '7⃣', '8⃣', '9⃣', '🔟']\n",
        "        description = []\n",
        "        for x, option in enumerate(options):\n",
        "            description += \"\\n{} {}\".format(reactions[x], option)\n",
        "        embed = discord.Embed(title=question, description=''.join(description))\n",
        "        react_message = await ctx.send(embed=embed)\n",
        "        for reaction in reactions[:len(options)]:\n",
        "            await react_message.add_reaction(reaction)\n",
        "        embed.set_footer(text='poll ID: {}'.format(react_message.id))\n",
        "        await react_message.edit(embed=embed)\n\n"
    ],
    "deposit":[
        "    @commands.command(aliases=[\"dep\"])\n",
        "    async def deposit(self, ctx, *, arg1:str):\n",
        "        if arg1 == \"all\" or arg1 == \"max\":\n",
        "            if userdat[str(ctx.message.author.id)][0] == 0: return await ctx.send(\"You don't have any coins in your wallet\")\n",
        "            else:\n",
        "                await ctx.reply(f\"You deposited {userdat[str(ctx.message.author.id)][0]} coins\")\n",
        "                userdat[str(ctx.message.author.id)][1] += int(userdat[str(ctx.message.author.id)][0])\n",
        "                userdat[str(ctx.message.author.id)][0] -= int(userdat[str(ctx.message.author.id)][0])\n",
        "                self.save()\n",
        "                return\n",
        "        try:\n",
        "            float(arg1)\n",
        "        except Exception as e:\n",
        "            if arg1.endswith(\"k\"):\n",
        "                i = arg1.replace(\"k\", \"\")\n",
        "                arg1 = int(i) * 1000\n",
        "            elif arg1.endswith(\"m\"):\n",
        "                i = arg1.replace(\"m\", \"\")\n",
        "                arg1 = int(i) * 1000000\n",
        "            elif arg1.endswith(\"b\"):\n",
        "                i = arg1.replace(\"b\", \"\")\n",
        "                arg1 = int(i) * 1000000000\n",
        "            else: return await ctx.reply(e)\n",
        "        if int(float(arg1)) <= 0 or not float(arg1).is_integer():\n",
        "            return await ctx.reply(\"Don't try to break me\")\n",
        "        if int(float(arg1)) > userdat[str(ctx.message.author.id)][0]: return await ctx.reply(\"You don't have that many coins in your wallet\")\n",
        "        elif int(float(arg1)) < 0: return await ctx.reply(\"Don't try to break me dood\")\n",
        "        else:\n",
        "            await ctx.send(f\"You deposited {int(float(arg1))} coins\")\n",
        "            userdat[str(ctx.message.author.id)][0] -= int(float(arg1))\n",
        "            userdat[str(ctx.message.author.id)][1] += int(float(arg1))\n",
        "            self.save()\n\n"
    ],
    "withdraw":[
        "    @commands.command(aliases=[\"with\"])\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def withdraw(self, ctx, *, arg1):\n",
        "        if arg1 == \"all\" or arg1 == \"max\":\n",
        "            if userdat[str(ctx.message.author.id)][1] == 0: return await ctx.send(\"You don't have any coins in your bank\")\n",
        "            else:\n",
        "                if userdat[str(ctx.message.author.id)][1] == 1: await ctx.reply(f\"You withdrawn {userdat[str(ctx.message.author.id)][1]} coin\")\n",
        "                else: await ctx.reply(f\"You withdrawn {userdat[str(ctx.message.author.id)][1]} coins\")\n",
        "                userdat[str(ctx.message.author.id)][0] += int(userdat[str(ctx.message.author.id)][1])\n",
        "                userdat[str(ctx.message.author.id)][1] -= int(userdat[str(ctx.message.author.id)][1])\n",
        "                self.save()\n",
        "                return\n",
        "        try:\n",
        "            float(action)\n",
        "        except Exception as e:\n",
        "            if action.endswith(\"k\"):\n",
        "                i = action.replace(\"k\", \"\")\n",
        "                action = int(i) * 1000\n",
        "            elif action.endswith(\"m\"):\n",
        "                i = action.replace(\"m\", \"\")\n",
        "                action = int(i) * 1000000\n",
        "            elif action.endswith(\"b\"):\n",
        "                i = action.replace(\"b\", \"\")\n",
        "                action = int(i) * 1000000000\n",
        "            else: return await ctx.reply(e)\n",
        "        if int(float(arg1)) <= 0 or not float(float(arg1)).is_integer():\n",
        "            return await ctx.reply(\"Don't try to break me\")\n",
        "        if int(float(arg1)) > userdat[str(ctx.message.author.id)][0]: return await ctx.reply(\"You don't have that many coins in your wallet\")\n",
        "        elif int(float(arg1)) < 0: return await ctx.reply(\"Don't try to break me\")\n",
        "        else:\n",
        "            await ctx.send(f\"You withdrawn {int(float(arg1))} coins\")\n",
        "            userdat[str(ctx.message.author.id)][0] += int(float(v))\n",
        "            userdat[str(ctx.message.author.id)][1] -= int(float(v))\n\n"
    ],
    "ban":[
        "    @commands.command()\n",
        "    @commands.has_permissions(ban_members=True)\n",
        "    async def ban(self, ctx, member:discord.Member):\n",
        "        if member == ctx.message.author: raise BadArgument\n",
        "        else: await member.ban()\n",
        "        await ctx.send(f\"{member} has been banned from the server\")\n\n"
    ],
    "kick":[
        "    @commands.command()\n",
        "    @commands.has_permissions(kick_members=True)\n",
        "    async def kick(self, ctx, member:discord.Member):\n",
        "        if member == ctx.message.author: raise BadArgument\n",
        "        else: await member.kick()\n",
        "        await ctx.send(f\"{member} has been kikced from the server\")\n\n"
    ],
    "kill":[
        "    @commands.command()\n",
        "    async def kill(self, ctx, user : discord.User=None):\n",
        "        if user == None:\n",
        "            await ctx.send(\"Please tag someone to kill\")\n",
        "        elif user.id == ctx.message.author.id:\n",
        "            await ctx.send(\"Ok you are dead, please tag someone else to kill\")\n",
        "        else:\n",
        "            responses = [\n",
        "                f\"**{user.display_name}** died from a dang baguette\",\n",
        "                f\"<@{ctx.message.author.id}> strikes **{user.display_name}** with the killing curse... *Avada Kedavra!*\",\n",
        "                f\"**{user.display_name} dies from dabbing too hard\",\n",
        "                f\"**{user.display_name}** ripped their own heart out to show their love for <@{ctx.message.author.id}>\"\n",
        "            ]\n",
        "            await ctx.send(f'{random.choice(responses)}')\n\n"
    ],
    "purge":[
        "    @commands.command()\n",
        "    @commands.has_permissions(manage_channels=True)\n",
        "    async def purge(self, ctx, amount:int):\n",
        "        if int(amount) == 0: return await ctx.reply(\"You can't purge 0 messages **dood**\")\n",
        "        elif int(amount) < 0: return await ctx.reply(\"You can't spawn messages\")\n",
        "        elif int(amount) > 500: return await ctx.reply(\"You can't purge more than 500 messages\")\n",
        "        await ctx.message.delete()\n",
        "        await ctx.channel.purge(limit=amount)\n",
        "        embedSuccessPurge = discord.Embed(title=\"Purge Successful\", description=f\"Purged {amount} messages from this channel.\", color=discord.Colour.random())\n",
        "        await ctx.send(embed = embedSuccessPurge)\n\n"
    ],
    "trivia":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 30, commands.BucketType.user)\n",
        "    async def trivia(self, ctx, difficulty:str=None):\n",
        "        if difficulty == None: r = requests.get(\"https://opentdb.com/api.php?amount=50&type=multiple\")\n",
        "        else: r = requests.get(f\"https://opentdb.com/api.php?amount=50&type=multiple&difficulty={difficulty}\")\n",
        "        if r.json()[\"response_code\"] != 0: return await ctx.reply(f\"{difficulty} is an invalid difficulty\")\n",
        "        rnd = random.choice(r.json()[\"results\"])\n",
        "        question = html.unescape(rnd[\"question\"])\n",
        "        rnd[\"correct_answer\"] = html.unescape(rnd[\"correct_answer\"])\n",
        "\n",
        "        for i in rnd[\"incorrect_answers\"]:\n",
        "            rnd[\"incorrect_answers\"][rnd[\"incorrect_answers\"].index(i)] = html.unescape(rnd[\"incorrect_answers\"][rnd[\"incorrect_answers\"].index(i)])\n",
        "\n",
        "        arr = list()\n",
        "        arr.append(rnd[\"correct_answer\"])\n",
        "        for i in rnd[\"incorrect_answers\"]:\n",
        "            arr.append(i)\n",
        "        random.seed(random.randint(1, 256))\n",
        "        random.shuffle(arr)\n",
        "        a = arr[0]\n",
        "        b = arr[1]\n",
        "        c = arr[2]\n",
        "        d = arr[3]\n",
        "        if rnd[\"difficulty\"] == \"easy\": timeout = 20\n",
        "        elif rnd[\"difficulty\"] == \"medium\": timeout = 30\n",
        "        elif rnd[\"difficulty\"] == \"hard\": timeout = 40\n",
        "        embed = discord.Embed(\n",
        "            title=f\"{question}\",\n",
        "            description=f\"\\nCategory: {rnd['category']}\\nDifficulty: {rnd['difficulty']}\\nAnswers:\\nA) {a}\\nB) {b}\\nC) {c}\\nD) {d}\\n\\nTime: {timeout} seconds\",\n",
        "            color=discord.Color.random()\n",
        "        )\n",
        "        embed.set_footer(text=f\"Trivia system made by {owner}\")\n",
        "        await ctx.send(embed=embed)\n",
        "        def check(msg):\n",
        "            return msg.author == ctx.message.author and msg.channel == ctx.message.channel and (msg.content)\n",
        "        try:\n",
        "            msg = await self.client.wait_for(\"message\", check=check, timeout=timeout)\n",
        "        except:\n",
        "            return await ctx.send(f\"You ran out of time! The correct answer was {rnd['correct_answer']}\")\n",
        "        if msg.content.lower() == \"a\" or msg.content.lower() == a.lower():\n",
        "            if a == rnd[\"correct_answer\"]:\n",
        "                if rnd[\"difficulty\"] == \"easy\": coins = random.randint(100, 1000)\n",
        "                elif rnd[\"difficulty\"] == \"medium\": coins = random.randint(2000, 5000)\n",
        "                elif rnd[\"difficulty\"] == \"hard\": coins = random.randint(5000, 10000)\n",
        "                userdat[str(ctx.message.author.id)][0] += coins\n",
        "                self.save()\n",
        "                await ctx.send(f\"Correct! You earned {coins} coins\")\n",
        "            else:\n",
        "                return await ctx.send(f\"Incorrect! The answer was \\\"{rnd['correct_answer']}\\\"\")\n",
        "        elif msg.content.lower() == \"b\" or msg.content.lower() == b.lower():\n",
        "            if b == rnd[\"correct_answer\"]:\n",
        "                if rnd[\"difficulty\"] == \"easy\": coins = random.randint(100, 1000)\n",
        "                elif rnd[\"difficulty\"] == \"medium\": coins = random.randint(2000, 5000)\n",
        "                elif rnd[\"difficulty\"] == \"hard\": coins = random.randint(5000, 10000)\n",
        "                userdat[str(ctx.message.author.id)][0] += coins\n",
        "                self.save()\n",
        "                await ctx.send(f\"Correct! You earned {coins} coins\")\n",
        "            else:\n",
        "                return await ctx.send(f\"Incorrect! The answer was \\\"{rnd['correct_answer']}\\\"\")\n",
        "        elif msg.content.lower() == \"c\" or msg.content.lower() == c.lower():\n",
        "            if c == rnd[\"correct_answer\"]:\n",
        "                if rnd[\"difficulty\"] == \"easy\": coins = random.randint(100, 1000)\n",
        "                elif rnd[\"difficulty\"] == \"medium\": coins = random.randint(2000, 5000)\n",
        "                elif rnd[\"difficulty\"] == \"hard\": coins = random.randint(5000, 10000)\n",
        "                userdat[str(ctx.message.author.id)][0] += coins\n",
        "                self.save()\n",
        "                await ctx.send(f\"Correct! You earned {coins} coins\")\n",
        "            else:\n",
        "                return await ctx.send(f\"Incorrect! The answer was \\\"{rnd['correct_answer']}\\\"\")\n",
        "        elif msg.content.lower() == \"d\" or msg.content.lower() == d.lower():\n",
        "            if d == rnd[\"correct_answer\"]:\n",
        "                if rnd[\"difficulty\"] == \"easy\": coins = random.randint(100, 1000)\n",
        "                elif rnd[\"difficulty\"] == \"medium\": coins = random.randint(2000, 5000)\n",
        "                elif rnd[\"difficulty\"] == \"hard\": coins = random.randint(5000, 10000)\n",
        "                userdat[str(ctx.message.author.id)][0] += coins\n",
        "                self.save()\n",
        "                await ctx.send(f\"Correct! You earned {coins} coins\")\n",
        "            else:\n",
        "                return await ctx.send(f\"Incorrect! The answer was \\\"{rnd['correct_answer']}\\\"\")\n",
        "        else:\n",
        "            return await ctx.send(f\"What is {msg.content}? Anyway the correct answer was \\\"{rnd['correct_answer']}\\\"\")\n\n"
    ],
    "bannedwords":[
        "    @commands.command()\n",
        "    @commands.has_permissions(manage_guild=True)\n",
        "    async def bannedwords(self, ctx, *wordlist:str):\n",
        "        if len(list(wordlist)) == 1 and wordlist[0] == \"default\":\n",
        "            words = open(\"db/defaultswear.txt\").read().splitlines()\n",
        "            for word in words: gdata[str(ctx.guild.id)][4].append(key)\n",
        "        else:\n",
        "            for word in wordlist: gdata[str(ctx.guild.id)][4].append(word)\n",
        "        self.save()\n",
        "        await ctx.reply(\"Updated banned word list\")\n\n"
    ],
    "sweartoggle":[
        "    @commands.command()\n",
        "    @commands.has_permissions(manage_guild=True)\n",
        "    async def sweartoggle(self, ctx):\n",
        "        if gdata[str(ctx.guild.id)][3] == 0: gdata[str(ctx.guild.id)] = 1\n",
        "        elif gdata[str(ctx.guild.id)][3] == 1: gdata[str(ctx.guild.id)] == 0\n",
        "        self.save()\n\n"
    ],
    "8ball":[
        "    @commands.command(aliases=[\"8ball\"])\n",
        "    async def _8ball(self, ctx, *, question):\n",
        "        responses = [\n",
        "                \"no?????.\",\n",
        "                \"when you grow a braincell, yes\",\n",
        "                \"you stupid, of course not\",\n",
        "                \"lol no\",\n",
        "                \"As I see it, yes.\",\n",
        "                \"Most likely.\",\n",
        "                \"Yes.\",\n",
        "                \"try again\",\n",
        "                \"ask again later.\",\n",
        "                \"Better not tell you now.\",\n",
        "                \"Cannot predict now.\",\n",
        "                \"Concentrate and ask again.\",\n",
        "                \"Don't count on it.\",\n",
        "                \"My reply is no.\",\n",
        "                \"My sources say no.\",\n",
        "                \"Outlook not so good.\"\n",
        "        ]\n",
        "        e = discord.Embed(title=question, description=random.choice(responses), color=discord.Colour.random())\n",
        "        await ctx.send(embed=e)\n\n"
    ],
    "rank":[
        "    @commands.command(aliases=['xp'])\n",
        "    async def rank(self, ctx, user : discord.User=None):\n",
        "        d = gdata[str(ctx.guild.id)][0]\n",
        "        if user == None: user = ctx.author\n",
        "        xpreq = 0\n",
        "        if d[str(ctx.message.author.id)][1] == 1: xpreq = 25\n",
        "        else:\n",
        "            for level in range(int(d[str(ctx.message.author.id)][1])):\n",
        "                xpreq += 25\n",
        "                if xpreq >= 5000: break\n",
        "        embed = discord.Embed(title=f\"{ctx.message.author.display_name}'s Rank\", color=discord.Colour.random())\n",
        "        embed.add_field(name=\"Level\", value=str(d[str(ctx.message.author.id)][1]))\n",
        "        xpv = f\"{d[str(ctx.message.author.id)][0]}/{xpreq}\"\n",
        "        embed.add_field(name=\"Exp\", value=str(xpv))\n",
        "        await ctx.send(embed=embed)\n\n"
    ],
    "balance":[
        "    @commands.command(aliases=['bal'])\n",
        "    async def balance(self, ctx, user:discord.User=None):\n",
        "        if user == None: user = ctx.author\n",
        "        if str(user.id) not in userdat: self.addv(userdat, str(user.id), [0, 0, 0])\n",
        "        embed=discord.Embed(title=f\"{user}'s balance\", description=f\"Wallet: {userdat[str(user.id)][0]}\\nBank: {userdat[str(user.id)][1]}\", color=discord.Color.random())\n",
        "        await ctx.reply(embed=embed)\n\n"
    ],
    "rob":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 300, commands.BucketType.user)\n",
        "    async def rob(self, ctx, user : discord.User):\n",
        "        if ctx.message.author.id == user.id: return await ctx.send('you cant rob yourself xd')\n",
        "        else:\n",
        "            if gdata[str(ctx.guild.id)][2] == 0: return await ctx.send('Robbing is disabled in this server')\n",
        "            if str(user.id) not in userdat or userdat[str(user.id)][0] < 500: return await ctx.send('This user has less than 500 coins')\n",
        "            elif userdat[str(user.id)][0] >= 500:\n",
        "                coins = random.randint(500, int(userdat[str(user.id)][0]))\n",
        "                userdat[str(user.id)][0] -= coins\n",
        "                userdat[str(ctx.message.author.id)][0] += coins\n",
        "                await ctx.send(f'You stole {coins} coins from **{user.display_name}**')\n\n"
    ],
    "lock":[
        "    @commands.command()\n",
        "    @commands.has_permissions(manage_channels=True)\n",
        "    async def lock(self, ctx, channel : discord.TextChannel=None):\n",
        "        channel = channel or ctx.channel\n",
        "        overwrite = channel.overwrites_for(ctx.guild.default_role)\n",
        "        overwrite.send_messages = False\n",
        "        await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)\n",
        "        em = discord.Embed(title=':white_check_mark: channel locked successfully.', color=discord.Colour.random())\n",
        "        await ctx.send(embed=em)\n\n"
    ],
    "unlock":[
        "    @commands.command()\n",
        "    @commands.has_permissions(manage_channels=True)\n",
        "    async def lock(self, ctx, channel : discord.TextChannel=None):\n",
        "        channel = channel or ctx.channel\n",
        "        overwrite = channel.overwrites_for(ctx.guild.default_role)\n",
        "        overwrite.send_messages = True\n",
        "        await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)\n",
        "        em = discord.Embed(title=':white_check_mark: channel unlocked successfully.', color=discord.Colour.random())\n",
        "        await ctx.send(embed=em)\n\n"
    ],
    "nuke":[
        "    @commands.command()\n",
        "    @commands.has_permissions(manage_channels=True)\n",
        "    async def nuke(self, ctx, channel: discord.TextChannel):\n",
        "        nuke_channel = discord.utils.get(ctx.guild.channels, name=channel.name)\n",
        "        if nuke_channel is not None:\n",
        "            new_channel = await nuke_channel.clone(reason=\"Has been Nuked!\")\n",
        "            await nuke_channel.delete()\n",
        "            await new_channel.send(\"This channel has been nuked!\")\n",
        "            await ctx.send(\"Nuked the Channel sucessfully!\")\n",
        "        else: await ctx.send(f\"No channel named {channel.name} was found!\")\n\n"
    ],
    "guess":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 30, commands.BucketType.user)\n",
        "    async def guess(self, ctx, num:int):\n",
        "        x = randint(1, 10)\n",
        "        if num == x:\n",
        "            coins = randint(100, 1000)\n",
        "            await ctx.reply(f'Correct! You got {coins} coins')\n",
        "            userdat[str(ctx.message.author.id)][0] += coins\n",
        "            self.save()\n",
        "        else:\n",
        "            await ctx.reply(f'Nope it was {x}')\n\n"
    ],
    "userinfo":[
        "    @commands.command()\n",
        "    async def userinfo(self, ctx, member:discord.Member=None):\n",
        "        if member == None: member = ctx.message.author\n",
        "        embed=discord.Embed(title=\"User Information\",  timestamp=datetime.datetime.utcnow(), color=discord.Color.random())\n",
        "        embed.set_thumbnail(url=member.avatar_url)\n",
        "        embed.add_field(name=\"Username:\", value=member.name, inline=False)\n",
        "        embed.add_field(name=\"Display name:\", value=member.nick, inline=False)\n",
        "        embed.add_field(name=\"User ID:\", value=member.id, inline=False)\n",
        "        embed.add_field(name=\"Account Created At:\",value=member.created_at.strftime(\"%a %#d %B %Y, %I:%M %p UTC\"), inline=False)\n",
        "        embed.add_field(name=\"Joined Server At:\",value=member.joined_at.strftime(\"%a %#d %B %Y, %I:%M %p UTC\"), inline=False)\n",
        "        await ctx.send(embed=embed)\n\n"
    ],
    "serverinfo":[
        "    @commands.command()\n",
        "    async def serverinfo(self, ctx):\n",
        "        name = str(ctx.guild.name)\n",
        "        description = str(ctx.guild.description)\n",
        "        gowner = str(ctx.guild.owner)\n",
        "        gid = str(ctx.guild.id)\n",
        "        memberCount = str(ctx.guild.member_count)\n",
        "        icon = str(ctx.guild.icon_url)\n",
        "        embed = discord.Embed(title=name + \" Server Information\", description=description, color=discord.Color.random())\n",
        "        embed.set_thumbnail(url=icon)\n",
        "        embed.add_field(name=\"Owner\", value=gowner, inline=True)\n",
        "        embed.add_field(name=\"Server ID\", value=gid, inline=True)\n",
        "        embed.add_field(name=\"Member Count\", value=memberCount, inline=True)\n\n"
    ],
    "invites":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def invites(self, ctx, *, user : discord.User=None):\n",
        "        totalInvites = 0\n",
        "        if user == None: user = ctx.author\n",
        "        if user.bot:\n",
        "            await ctx.reply('This is a bot not a user')\n",
        "        else:\n",
        "            for i in await ctx.guild.invites():\n",
        "                if i.inviter == user:\n",
        "                    totalInvites += i.uses\n",
        "            e = discord.Embed(title=f\"{user.display_name}'s total invites\", description=f\"{totalInvites} invites\", color=discord.Colour.random())\n",
        "            await ctx.reply(embed=e)\n\n"
    ],
    "isSus":[
        "    @commands.command(aliases=['sus'])\n",
        "    async def isSus(self, ctx, user:discord.User=None):\n",
        "        if user == None: user = ctx.author\n",
        "        await ctx.reply(f\"{user.mention} {'is very sus' if random.choice([True, False]) == True else 'isnt sus'}\")\n\n"
    ],
    "invite":[
        "    @commands.command()\n",
        "    async def invite(self, ctx):\n",
        "        await ctx.reply(f\"https://discord.com/api/oauth2/authorize?client_id={clientid}&permissions=8&scope=bot\")\n\n"
    ],
    "sum":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def sum(self, ctx, *nums:float)\n",
        "        ans = 0\n",
        "        arr = list()\n",
        "        for num in nums:\n",
        "            ans += num\n",
        "            arr.append(str(num))\n",
        "        var = ' + '.join(arr)\n",
        "        await ctx.send(f'`{var}` = __{ans}__\n--end of calculation--'')\n\n"
    ],
    "subtract":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def subtract(self, ctx, *nums:float):\n",
        "        nums = list(nums)\n",
        "        arr = list()\n",
        "        arr.append(str(nums[0]))\n",
        "        ans = nums[0]\n",
        "        nums.remove(nums[0])\n",
        "        for num in nums:\n",
        "            ans -= num\n",
        "            arr.append(str(num))\n",
        "        var = ' - '.join(arr)\n",
        "        await ctx.send(f'`{var}` = __{ans}__\n--end of calculation--')\n\n"
     ],
     "multiply":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def multiply(self, ctx, num1: float, num2: float):\n",
        "        ans = str(num1 * num2)\n",
        "        await ctx.send(f'`{num1} × {num2}` = __{ans}__\n\n--end of calculation--')\n\n"
     ],
     "divide":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def divide(self, ctx, num1: float, num2: float):\n",
        "        if num2 == 0:\n",
        "            await ctx.send('math error: divided by zero.'')\n",
        "            return\n",
        "        ans = str(num1 / num2)\n",
        "        await ctx.send(f'`{num1} ÷ {num2}` = __{ans}__\n\n--end of calculation--')\n\n"
     ],
     "power":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def power(self, ctx, num1: float, num2: int):\n",
        "        ans = str(num1 ** num2)\n",
        "        await ctx.send(f'`{num1} ^ {num2}` = __{ans}__\n\n--end of calculation--')\n\n"
     ],
     "squareroot":[
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def squareroot(self, ctx, num: float):\n",
        "        ans = cmath.sqrt(num)\n",
        "        await ctx.send(f'`√ {num}` = __{ans}__\n\n--end of calculation--')\n\n"
     ],
     "cexec":[
        "def cleanup_code(content):\n",
	    "    if content.startswith('```') and content.endswith: return '\n'.join(content.split('\n')[1:-1])\n",
        "	 return content.strip('` \n')\n\n",
        "    @commands.command()\n",
        "    @commands.cooldown(1, 5, commands.BucketType.user)\n",
        "    async def cexec(self, ctx, *, body):\n",
        "	     body = cleanup_code(body)\n",
        "  	     if os.path.isfile(\"./a.out\"): os.system(\"rm -r ./a.out\")\n",
        "	     if os.path.isfile(\"./file1.c\"): os.system(\"rm -r ./file1.c\")\n",
        "	     f = open(\"./file1.c\", \"w\")\n",
        "	     f.write(body)\n",
        "	     f.close()\n",
        "	     c = subprocess.run(\"gcc ./file1.c\", capture_output=True, text=True, shell=True)\n",
        "	     if c.returncode != 0: return await ctx.send(f\"```c\n{c.stderr}```\")\n",
        "	     p = subprocess.check_output(\"./a.out\", shell=True)\n",
        "	     return await ctx.send(f\"```c\n{p.decode()}\n```\")\n\n"
     ]
}
